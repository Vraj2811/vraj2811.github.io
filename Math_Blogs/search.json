[
  {
    "objectID": "Math/Taylor_Series.html",
    "href": "Math/Taylor_Series.html",
    "title": "Taylor Series",
    "section": "",
    "text": "\\[ f(x) = f(a) + f'(a)(x - a) + \\frac{f''(a)(x - a)^2}{2!} + \\frac{f'''(a)(x - a)^3}{3!} + \\cdots \\]\n\nImport Libraries\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\nFactorial\n\\[ x! = x \\times (x-1) \\times (x-2) \\times \\ldots \\times 3 \\times 2 \\times 1 \\]\n\ndef factorial(x):\n    if x&lt;=1:\n        return 1\n    else:\n        product=1\n        for i in range(1,x+1):\n            product*=i\n        return product\n\n\n\nDefining Function\n\ndef function(x):\n    return 1 + x + x**2 + x**3 + x**4\n\n\n\nSetting up the variables\n\nx=1     # Point where we like to approximate the value of fxn\na=0     # Value of x where we know about the fxn\n\n\n\nFind nth derivative of a fxn at point a\n\ndef derivative(f, x, n):\n    if n == 0:\n        return f(x)\n    else:\n        h = 1e-2\n        df = (derivative(f, x + h, n - 1) - derivative(f, x, n - 1)) / h\n        return df\n\n\n\nExact Ans\n\nexact=function(x)\n\n\n\nEstimated Answers\n\ndef estimate(terms, a, x):\n    sum = 0\n    for i in range(terms):\n        sum += derivative(function, a, i) * (x - a)**(i) / np.math.factorial(i)\n    return sum\n\n\norder = []\nerrors = []\n\nprint(\"Order\\tExact\\t\\tEstimate\\tError (%)\")\nprint(\"-------------------------------------------------------\")\nfor i in range(1, 11):\n    estimate_ans = estimate(i, a, x)\n    error = np.abs(exact-estimate_ans)/exact*100\n    print(f\"{i-1}\\t{exact:.9f}\\t{estimate_ans:.9f}\\t{error:.9f}%\")\n    order.append(i-1)\n    errors.append(error)\n\nplt.figure(figsize=(5, 3))\nplt.plot(order, errors, marker='o')\nplt.xlabel(\"Order\")\nplt.ylabel(\"Error (%)\")\nplt.title(\"Error vs. Order\")\nplt.grid(True)\nplt.show()\n\nOrder   Exact       Estimate    Error (%)\n-------------------------------------------------------\n0   5.000000000 1.000000000 80.000000000%\n1   5.000000000 2.010101000 59.797980000%\n2   5.000000000 3.040801000 39.183980000%\n3   5.000000000 4.100801000 17.983980001%\n4   5.000000000 5.100801002 2.016020044%\n5   5.000000000 5.100800873 2.016017454%\n6   5.000000000 5.100806732 2.016134644%\n7   5.000000000 5.100599667 2.011993336%\n8   5.000000000 5.106547290 2.130945803%\n9   5.000000000 4.963363765 0.732724697%\n\n\n\n\n\n\n\nPlotting the Exact and Approx Functions\n\nx_values = np.linspace(-5, 5, 400)\na = 0\n\nfor terms in range(2,6):\n    plt.figure()\n    approx_y_values = [estimate(terms, a, x) for x in x_values]\n    plt.plot(x_values, approx_y_values, label=f'Taylor Series (Terms = {terms})')\n    plt.plot(x_values, function(x_values), label='Actual Function')\n    plt.title(f\"Taylor Series (Terms = {terms}) vs. Actual Function\")\n    plt.xlabel(\"x\")\n    plt.ylabel(\"f(x)\")\n    plt.legend()\n    plt.grid(True)\n    plt.show() \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlotting the graphs for Sin(x)\n\ndef function(x):\n    return np.sin(x)\n\nx_values = np.linspace(-5, 5, 400)\na = 0\n\nfor terms in range(2,10,2):\n    plt.figure()\n    approx_y_values = [estimate(terms, a, x) for x in x_values]\n    plt.plot(x_values, approx_y_values, label=f'Taylor Series (Terms = {terms})')\n    plt.plot(x_values, function(x_values), label='Actual Function')\n    plt.title(f\"Taylor Series (Terms = {terms}) vs. Actual Function\")\n    plt.xlabel(\"x\")\n    plt.ylabel(\"f(x)\")\n    plt.legend()\n    plt.grid(True)\n    plt.show()"
  },
  {
    "objectID": "Math/Maclaurin_Series.html",
    "href": "Math/Maclaurin_Series.html",
    "title": "Maclaurin Series",
    "section": "",
    "text": "\\[\ne^x = 1 + x + \\frac{{x^2}}{2!} + \\frac{{x^3}}{3!} + \\ldots\n\\]\n\nImport Libraries\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\nFactorial\n\\[ x! = x \\times (x-1) \\times (x-2) \\times \\ldots \\times 3 \\times 2 \\times 1 \\]\n\ndef factorial(x):\n    if x&lt;=1:\n        return 1\n    else:\n        product=1\n        for i in range(1,x+1):\n            product*=i\n        return product\n\n\n\nLet x = 0.5\n\nx=0.5\n\n\nExact Ans\n\nexact=np.exp(x)\n\n\n\nEstimated Answers\n\ndef estimate(terms,x):\n    sum = 0\n    for i in range(terms+1):\n        sum += i*(x**(i-1))/factorial(i)\n    return sum\n\n\n\nErrors for each term -&gt;\n\nterms = []\nerrors = []\n\nprint(\"Terms\\tExact\\t\\tEstimate\\tError (%)\")\nprint(\"-------------------------------------------------------\")\nfor i in range(1,11):\n    estimate_ans=estimate(i,x)\n    error=(exact-estimate_ans)/exact*100\n    print(f\"{i}\\t{exact:.9f}\\t{estimate_ans:.9f}\\t{error:.9f}%\")\n    terms.append(i)\n    errors.append(error)\n\nplt.figure(figsize=(5, 3))\nplt.plot(terms, errors, marker='o')\nplt.xlabel(\"Number of Terms\")\nplt.ylabel(\"Error (%)\")\nplt.title(\"Error vs. Number of Terms\")\nplt.grid(True)\nplt.show()\n\nTerms   Exact       Estimate    Error (%)\n-------------------------------------------------------\n1   1.648721271 1.000000000 39.346934029%\n2   1.648721271 1.500000000 9.020401043%\n3   1.648721271 1.625000000 1.438767797%\n4   1.648721271 1.645833333 0.175162256%\n5   1.648721271 1.648437500 0.017211563%\n6   1.648721271 1.648697917 0.001416494%\n7   1.648721271 1.648719618 0.000100238%\n8   1.648721271 1.648721168 0.000006220%\n9   1.648721271 1.648721265 0.000000344%\n10  1.648721271 1.648721270 0.000000017%\n\n\n\n\n\n\n\n\nLet x = 5\n\nx=5\n\n\nExact Ans\n\nexact=np.exp(x)\n\n\n\nEstimated Answers\n\ndef estimate(terms,x):\n    sum = 0\n    for i in range(terms+1):\n        sum += i*(x**(i-1))/factorial(i)\n    return sum\n\n\n\nErrors for each term -&gt;\n\nterms = []\nerrors = []\n\nprint(\"Terms\\tExact\\t\\tEstimate\\tError (%)\")\nprint(\"-------------------------------------------------------\")\nfor i in range(1,11):\n    estimate_ans=estimate(i,x)\n    error=(exact-estimate_ans)/exact*100\n    print(f\"{i}\\t{exact:.9f}\\t{estimate_ans:.9f}\\t{error:.9f}%\")\n    terms.append(i)\n    errors.append(error)\n\nplt.figure(figsize=(5, 3))\nplt.plot(terms, errors, marker='o')\nplt.xlabel(\"Number of Terms\")\nplt.ylabel(\"Error (%)\")\nplt.title(\"Error vs. Number of Terms\")\nplt.grid(True)\nplt.show()\n\nTerms   Exact       Estimate    Error (%)\n-------------------------------------------------------\n1   148.413159103   1.000000000 99.326205300%\n2   148.413159103   6.000000000 95.957231801%\n3   148.413159103   18.500000000    87.534798052%\n4   148.413159103   39.333333333    73.497408470%\n5   148.413159103   65.375000000    55.950671493%\n6   148.413159103   91.416666667    38.403934517%\n7   148.413159103   113.118055556   23.781653703%\n8   148.413159103   128.619047619   13.337167407%\n9   148.413159103   138.307167659   6.809363472%\n10  148.413159103   143.689456570   3.182805731%\n\n\n\n\n\n\n\n\nPlotting the graph\n\nx_vals = np.linspace(-5, 5, 400)\nexact_vals = np.exp(x_vals)\n\nfor terms in range(2,8):\n    plt.figure()\n    approx_y_values = [estimate(terms, x) for x in x_vals]\n    plt.plot(x_vals, approx_y_values, label=f'Taylor Series (Terms = {terms})')\n    plt.plot(x_vals, exact_vals, label='Actual Function')\n    plt.title(f\"Maclaurin Series (Terms = {terms}) vs. Actual Function\")\n    plt.xlabel(\"x\")\n    plt.ylabel(\"f(x)\")\n    plt.legend()\n    plt.grid(True)\n    plt.show()"
  },
  {
    "objectID": "Math/Newton_Raphson_Method.html",
    "href": "Math/Newton_Raphson_Method.html",
    "title": "Newton Raphson Method",
    "section": "",
    "text": "- Start with an initial guess x_0 .\n- Calculate the next value: \n\\[ x_{i+1} = x_i - \\frac{f(x_i)}{f'(x_i)} \\] - If |x_{i+1} - x_i| &lt; tol, consider x_{i+1} as the root approximation. - Repeat until convergence or a maximum number of iterations.\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n\n\n\ndef derivative(f, x, n=1):\n    if n == 0:\n        return f(x)\n    else:\n        h = 1e-7\n        df = (derivative(f, x + h, n - 1) - derivative(f, x, n - 1)) / h\n        return df\n\n\n\n\n\ndef method(func, a, tol=1e-6, max_iter=100):\n    x = a\n    iter_count = 1\n    x_next = np.inf\n    Ea = 100\n    iteration_data = []\n\n    print(\"Iteration |    x     |   f(x)    |   Ea (%)\")\n    print(\"-----------------------------------------\")\n\n    while abs(x_next - x) &gt; tol and iter_count &lt;= max_iter:\n        print(f\"{iter_count:9d} | {x:.6f} | {func(x):.6f} | {Ea:.3f}\")\n        iteration_data.append([iter_count, x, func(x),Ea])\n        x_next = x\n        x = x - func(x)/derivative(func, x)\n        Ea = abs((x - x_next) / x) * 100\n\n        iter_count += 1\n\n    return x_next, np.array(iteration_data)\n\n\n\n\n\ndef function(x):\n    return x**10 - 1\n\n\n\n\n\na = 0.5\ntolerance = 1e-8\n\n\n\n\n\nroot, iteration_data = method(function, a, tol=tolerance)\nprint(\"\")\nprint(\"Approximate root of f(x):\", root)\nprint(\"Function value f(x) at root:\", function(root))\n\nIteration |    x     |   f(x)    |   Ea (%)\n-----------------------------------------\n        1 | 0.500000 | -0.999023 | 100.000\n        2 | 51.649954 | 135113690901380928.000000 | 99.032\n        3 | 46.484958 | 47111232049568312.000000 | 11.111\n        4 | 41.836463 | 16426671305578640.000000 | 11.111\n        5 | 37.652816 | 5727626277965569.000000 | 11.111\n        6 | 33.887535 | 1997099844284967.750000 | 11.111\n        7 | 30.498781 | 696345678907932.125000 | 11.111\n        8 | 27.448903 | 242800732193370.531250 | 11.111\n        9 | 24.704013 | 84659383044679.875000 | 11.111\n       10 | 22.233612 | 29518902554876.765625 | 11.111\n       11 | 20.010251 | 10292605236473.214844 | 11.111\n       12 | 18.009226 | 3588809676042.216309 | 11.111\n       13 | 16.208303 | 1251340610956.026611 | 11.111\n       14 | 14.587473 | 436315510284.655945 | 11.111\n       15 | 13.128726 | 152133815904.294373 | 11.111\n       16 | 11.815853 | 53045783355.130203 | 11.111\n       17 | 10.634268 | 18495921653.552906 | 11.111\n       18 | 9.570841 | 6449129365.952678 | 11.111\n       19 | 8.613757 | 2248672469.611401 | 11.111\n       20 | 7.752381 | 784063648.806846 | 11.111\n       21 | 6.977143 | 273386108.233308 | 11.111\n       22 | 6.279429 | 95323848.705180 | 11.111\n       23 | 5.651486 | 33237373.351744 | 11.111\n       24 | 5.086338 | 11589156.292802 | 11.111\n       25 | 4.577704 | 4040889.081908 | 11.111\n       26 | 4.119934 | 1408970.796211 | 11.111\n       27 | 3.707941 | 491277.536645 | 11.111\n       28 | 3.337147 | 171297.643950 | 11.111\n       29 | 3.003435 | 59727.540221 | 11.111\n       30 | 2.703096 | 20825.445087 | 11.111\n       31 | 2.432800 | 7261.121147 | 11.111\n       32 | 2.189553 | 2531.533037 | 11.109\n       33 | 1.970684 | 882.427366 | 11.106\n       34 | 1.773839 | 307.419794 | 11.097\n       35 | 1.597030 | 106.927412 | 11.071\n       36 | 1.438807 | 37.021194 | 10.997\n       37 | 1.298711 | 12.649730 | 10.787\n       38 | 1.178354 | 4.161293 | 10.214\n       39 | 1.083349 | 1.226822 | 8.770\n       40 | 1.023665 | 0.263504 | 5.831\n       41 | 1.002316 | 0.023403 | 2.130\n       42 | 1.000024 | 0.000239 | 0.229\n       43 | 1.000000 | 0.000000 | 0.002\n\nApproximate root of f(x): 1.0000000025885265\nFunction value f(x) at root: 2.588526526459134e-08\n\n\n\n\n\n\nplt.plot(iteration_data[:, 0], iteration_data[:, 1],\n         marker='o', linestyle='-', label='Approximation')\nplt.xlabel('Iteration')\nplt.ylabel('Approximation')\nplt.title('Newton-Raphson Method Iterations')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\\[ E_{i+1} = -\\frac{f''(x)}{2 \\cdot f'(x)} \\cdot E_i^2 \\]"
  },
  {
    "objectID": "Math/False_Position_Method.html",
    "href": "Math/False_Position_Method.html",
    "title": "False Position Method",
    "section": "",
    "text": "- Choose an interval [a, b] where the function changes sign\n\\[ {f(a) \\times f(b) &lt; 0}\\] - Calculate the x-coordinate of the new point c on the x-axis: \\[\nc = b - \\frac{f(b) \\times (a - b)}{f(a) - f(b)}  = \\frac{a \\times f(b) - b \\times f(a)}{f(b) - f(a)}\n\\] - Evaluate the function at c, f(c). - If f(c) is very close to zero or if the interval width is smaller than a specified tolerance, return c as the root. - Determine which subinterval ([a, c] or [c, b]) has a sign change and adjust a or b accordingly. - Repeat steps 2-5 until the interval width is smaller than the tolerance.\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n\n\n\ndef method(func, a, b, tol=1e-6, max_iter=100):\n    if func(a) * func(b) &gt;= 0:\n        raise ValueError(\n            \"Function must have opposite signs at interval endpoints.\")\n\n    iter_count = 1\n    prev_root = 0\n    iteration_data = []\n\n    print(\"Iteration |   a    |    b   |   c    |   Ea (%)   |   Et (%)\")\n    print(\"---------------------------------------------------------\")\n    \n    f_c=np.inf\n    \n    while abs(f_c) &gt; tol and iter_count &lt; max_iter:\n        c = (a * func(b) - b * func(a)) / (func(b) - func(a))\n        f_c=func(c)\n        Ea = abs((c - prev_root) / c) * 100\n        iteration_data.append((iter_count, a, b, c, func(a), func(b), func(c)))\n        Et = abs(func(c)) * 100\n        print(f\"{iter_count:9d} | {a:.4f} | {b:.4f} | {c:.4f} | {Ea:.6f} | {Et:.6f}\")\n\n        if func(c) == 0:\n            return c\n        elif func(c) * func(a) &lt; 0:\n            b = c\n        else:\n            a = c\n        prev_root = c\n        iter_count += 1\n\n    return c, iteration_data\n\n\n\n\n\ndef function(x):\n    return x**3 - 4*x**2 + 7*x - 3\n\n\n\n\n\na = 0.0\nb = 2.0\ntolerance = 1e-6\n\n\n\n\n\nroot, iteration_data = method(function, a, b, tol=tolerance)\nprint(\"\")\nprint(\"Approximate root:\", root)\nprint(\"Function value at root:\", function(root))\n\nIteration |   a    |    b   |   c    |   Ea (%)   |   Et (%)\n---------------------------------------------------------\n        1 | 0.0000 | 2.0000 | 1.0000 | 100.000000 | 100.000000\n        2 | 0.0000 | 1.0000 | 0.7500 | 33.333333 | 42.187500\n        3 | 0.0000 | 0.7500 | 0.6575 | 14.062500 | 15.762036\n        4 | 0.0000 | 0.6575 | 0.6247 | 5.254012 | 5.572635\n        5 | 0.0000 | 0.6247 | 0.6133 | 1.857545 | 1.929884\n        6 | 0.0000 | 0.6133 | 0.6094 | 0.643295 | 0.663488\n        7 | 0.0000 | 0.6094 | 0.6081 | 0.221163 | 0.227530\n        8 | 0.0000 | 0.6081 | 0.6076 | 0.075843 | 0.077959\n        9 | 0.0000 | 0.6076 | 0.6074 | 0.025986 | 0.026703\n       10 | 0.0000 | 0.6074 | 0.6074 | 0.008901 | 0.009146\n       11 | 0.0000 | 0.6074 | 0.6074 | 0.003049 | 0.003132\n       12 | 0.0000 | 0.6074 | 0.6074 | 0.001044 | 0.001073\n       13 | 0.0000 | 0.6074 | 0.6074 | 0.000358 | 0.000367\n       14 | 0.0000 | 0.6074 | 0.6074 | 0.000122 | 0.000126\n       15 | 0.0000 | 0.6074 | 0.6074 | 0.000042 | 0.000043\n\nApproximate root: 0.6073533509777344\nFunction value at root: 4.309203518459981e-07\n\n\n\n\n\n\nfor data in iteration_data[:5]:\n    iter_count, a, b, c, f_a, f_b, f_c = data\n    plt.figure()\n    x_vals = np.linspace(a, b, 400)\n    y_vals = function(x_vals)\n    plt.plot(x_vals, y_vals, label='Function')\n    plt.scatter([a, b, c], [function(a), function(b), function(c)], color=['red', 'green', 'blue'])\n    plt.annotate('a', (a, function(a)), textcoords=\"offset points\", xytext=(0,10), ha='center', fontsize=15, color='red')\n    plt.annotate('b', (b, function(b)), textcoords=\"offset points\", xytext=(0,10), ha='center', fontsize=15, color='green')\n    plt.annotate('c', (c, function(c)), textcoords=\"offset points\", xytext=(0,10), ha='center', fontsize=15, color='blue')\n    \n    plt.axhline(y=0, color='black', linewidth=0.8)\n    plt.axvline(x=0, color='black', linewidth=0.8)\n    \n    # Calculate the x-coordinate of the intersection point\n    intersection_x = a - (a - b) * function(a) / (function(a) - function(b))\n    \n    plt.plot([a, b], [function(a), function(b)], color='purple', linestyle='--')\n    \n    # Draw a line connecting the intersection point to c\n    plt.plot([intersection_x, c], [0, function(c)], color='orange', linestyle='--')\n\n    plt.xlabel('x')\n    plt.ylabel('f(x)')\n    plt.legend()\n    plt.grid()\n    plt.title(f\"Iteration {iter_count}\")\n    plt.show()"
  },
  {
    "objectID": "Math/Bisection_Method.html",
    "href": "Math/Bisection_Method.html",
    "title": "Bisection Method",
    "section": "",
    "text": "- Choose an interval [a, b] where the function changes sign (f(a) * f(b) &lt; 0).\n- Calculate the midpoint c = (a + b) / 2.\n- Evaluate the function at the midpoint, f(c).\n- If f(c) is very close to zero or if the interval width is smaller than a specified tolerance, return c as the root.\n- Determine which subinterval ([a, c] or [c, b]) has a sign change and adjust a or b accordingly.\n- Repeat steps 2-5 until the interval width is smaller than the tolerance.\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n\n\n\ndef bisection_method(func, a, b, tol=1e-6, max_iter=100):\n    if func(a) * func(b) &gt;= 0:\n        raise ValueError(\"Function must have opposite signs at interval endpoints.\")\n\n    iter_count = 1\n    prev_root = 0\n    iteration_data = []\n    \n    print(\"Iteration |   a    |    b   |   c    |   Ea (%)   |   Et (%)\")\n    print(\"---------------------------------------------------------\")\n    \n    while (b - a)&gt; tol and iter_count &lt; max_iter:\n        c = (a + b) / 2\n        \n        \n        Ea = abs((c - prev_root) / c) * 100\n        iteration_data.append((iter_count, a, b, c, func(a), func(b), func(c)))\n        Et = abs(func(c)) * 100\n        print(f\"{iter_count:9d} | {a:.4f} | {b:.4f} | {c:.4f} | {Ea:.6f} | {Et:.6f}\")\n        \n        if func(c) == 0:\n            return c\n        elif func(c) * func(a) &lt; 0:\n            b = c\n        else:\n            a = c\n        prev_root = c\n        iter_count += 1\n\n    return c,iteration_data\n\n\n\n\n\ndef function(x):\n    return x**3 - 4*x**2 + 7*x - 3\n\n\n\n\n\na = 0.0\nb = 2.0\ntolerance = 1e-6\n\n\n\n\n\nroot,iteration_data = bisection_method(function, a, b, tol=tolerance)\nprint(\"\")\nprint(\"Approximate root:\", root)\nprint(\"Function value at root:\", function(root))\n\nIteration |   a    |    b   |   c    |   Ea (%)   |   Et (%)\n---------------------------------------------------------\n        1 | 0.0000 | 2.0000 | 1.0000 | 100.000000 | 100.000000\n        2 | 0.0000 | 1.0000 | 0.5000 | 100.000000 | 37.500000\n        3 | 0.5000 | 1.0000 | 0.7500 | 33.333333 | 42.187500\n        4 | 0.5000 | 0.7500 | 0.6250 | 20.000000 | 5.664062\n        5 | 0.5000 | 0.6250 | 0.5625 | 11.111111 | 15.014648\n        6 | 0.5625 | 0.6250 | 0.5938 | 5.263158 | 4.458618\n        7 | 0.5938 | 0.6250 | 0.6094 | 2.564103 | 0.655746\n        8 | 0.5938 | 0.6094 | 0.6016 | 1.298701 | 1.888037\n        9 | 0.6016 | 0.6094 | 0.6055 | 0.645161 | 0.612813\n       10 | 0.6055 | 0.6094 | 0.6074 | 0.321543 | 0.022297\n       11 | 0.6055 | 0.6074 | 0.6064 | 0.161031 | 0.295050\n       12 | 0.6064 | 0.6074 | 0.6069 | 0.080451 | 0.136324\n       13 | 0.6069 | 0.6074 | 0.6072 | 0.040209 | 0.057001\n       14 | 0.6072 | 0.6074 | 0.6073 | 0.020101 | 0.017348\n       15 | 0.6073 | 0.6074 | 0.6074 | 0.010049 | 0.002475\n       16 | 0.6073 | 0.6074 | 0.6073 | 0.005025 | 0.007436\n       17 | 0.6073 | 0.6074 | 0.6073 | 0.002512 | 0.002480\n       18 | 0.6073 | 0.6074 | 0.6074 | 0.001256 | 0.000003\n       19 | 0.6074 | 0.6074 | 0.6074 | 0.000628 | 0.001236\n       20 | 0.6074 | 0.6074 | 0.6074 | 0.000314 | 0.000617\n       21 | 0.6074 | 0.6074 | 0.6074 | 0.000157 | 0.000307\n\nApproximate root: 0.6073541641235352\nFunction value at root: 3.0718599188794826e-06\n\n\n\n\n\n\nfor data in iteration_data[:10]:\n    iter_count, a, b, c, f_a, f_b, f_c = data\n    plt.figure()\n    x_vals = np.linspace(a, b, 400)\n    y_vals = function(x_vals)\n    plt.plot(x_vals, y_vals, label='Function')\n    plt.scatter([a, b, c], [function(a), function(b), function(c)], color=['red', 'green', 'blue'])\n    plt.annotate('a', (a, function(a)), textcoords=\"offset points\", xytext=(0,10), ha='center', fontsize=10, color='red')\n    plt.annotate('b', (b, function(b)), textcoords=\"offset points\", xytext=(0,10), ha='center', fontsize=10, color='green')\n    plt.annotate('c', (c, function(c)), textcoords=\"offset points\", xytext=(0,10), ha='center', fontsize=10, color='blue')\n    plt.xlabel('x')\n    plt.ylabel('f(x)')\n    plt.legend()\n    plt.grid()\n    plt.title(f\"Iteration {iter_count}\")\n    plt.show()"
  },
  {
    "objectID": "Math/Single_Fixed_Point_Iteration.html",
    "href": "Math/Single_Fixed_Point_Iteration.html",
    "title": "Single Fixed Point Iteration Algorithm",
    "section": "",
    "text": "- Start with an initial guess x_0.\n  - Calculate the next value: x_{i+1} = g(x_i).\n  - If |x_{i+1} - x_i| &lt; tol, consider x_{i+1} as the fixed point.\n  - Repeat until convergence or a max number of iterations.\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n\n\n\ndef single_point_iteration(func, a, tol=1e-6, max_iter=100):\n    x = a\n    iter_count = 1\n    x_next = np.inf\n    \n    iteration_data = []\n    \n    print(\"Iteration |    x     |    g(x)  |   Ea (%)\")\n    print(\"-----------------------------------------\")\n    \n    while abs(x_next - x) &gt; tol and iter_count &lt;= max_iter:\n        iteration_data.append([iter_count,x,func(x)])\n        x_next = x\n        x = func(x)\n        Ea = abs((x - x_next) / x) * 100\n        \n        print(f\"{iter_count:9d} | {x:.6f} | {func(x):.6f} | {Ea:.3f}\")\n        \n        iter_count += 1\n\n    return x_next , np.array(iteration_data)\n\n\n\n\n\\[\nf(x)=0\n\\] \\[\n\\large x = g(x)\n\\]\n\ndef function(x):\n    return np.exp(-x)\n\n\n\n\n\na = 0.0\ntolerance = 1e-6\n\n\n\n\n\nroot,iteration_data = single_point_iteration(function, a, tol=tolerance)\nprint(\"\")\nprint(\"Approximate root of g(x):\", root)\nprint(\"Function value f(x) at root:\", function(root)-root)\n\nIteration |    x     |    g(x)  |   Ea (%)\n-----------------------------------------\n        1 | 1.000000 | 0.367879 | 100.000\n        2 | 0.367879 | 0.692201 | 171.828\n        3 | 0.692201 | 0.500474 | 46.854\n        4 | 0.500474 | 0.606244 | 38.309\n        5 | 0.606244 | 0.545396 | 17.447\n        6 | 0.545396 | 0.579612 | 11.157\n        7 | 0.579612 | 0.560115 | 5.903\n        8 | 0.560115 | 0.571143 | 3.481\n        9 | 0.571143 | 0.564879 | 1.931\n       10 | 0.564879 | 0.568429 | 1.109\n       11 | 0.568429 | 0.566415 | 0.624\n       12 | 0.566415 | 0.567557 | 0.356\n       13 | 0.567557 | 0.566909 | 0.201\n       14 | 0.566909 | 0.567276 | 0.114\n       15 | 0.567276 | 0.567068 | 0.065\n       16 | 0.567068 | 0.567186 | 0.037\n       17 | 0.567186 | 0.567119 | 0.021\n       18 | 0.567119 | 0.567157 | 0.012\n       19 | 0.567157 | 0.567135 | 0.007\n       20 | 0.567135 | 0.567148 | 0.004\n       21 | 0.567148 | 0.567141 | 0.002\n       22 | 0.567141 | 0.567145 | 0.001\n       23 | 0.567145 | 0.567142 | 0.001\n       24 | 0.567142 | 0.567144 | 0.000\n       25 | 0.567144 | 0.567143 | 0.000\n       26 | 0.567143 | 0.567143 | 0.000\n\nApproximate root of g(x): 0.5671437480994115\nFunction value f(x) at root: -7.172651695919185e-07\n\n\n\n\n\n\nplt.figure(figsize=(10, 6))\nplt.plot(iteration_data[:,0], iteration_data[:,1], marker='o', label='x')\nplt.plot(iteration_data[:,0], iteration_data[:,2], marker='x', label='f(x)')\nplt.xlabel('Iteration')\nplt.ylabel('Values')\nplt.title('Values of x and g(x) over Iterations')\nplt.legend()\nplt.grid(True)\nplt.show()"
  },
  {
    "objectID": "Math/Euler's_Method.html",
    "href": "Math/Euler's_Method.html",
    "title": "Eulerâ€™s Method",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "Math/Secant_Method.html",
    "href": "Math/Secant_Method.html",
    "title": "Secant Method",
    "section": "",
    "text": "- Start with two initial guesses, x_0 and x_1.\n- For i = 2, 3, ... until convergence or max iterations:\n- Calculate the function values at x_i and x_{i-1}: f(x_i) and f(x_{i-1}).\n- Calculate the next approximation using the secant formula:\n\\[\n     x_{i+1} = x_i - f(x_i) \\frac{(x_i - x_{i-1})}{(f(x_i) - f(x_{i-1}))}\n\\] - If |x_{i+1} - x_i| &lt; tol or |f(x_{i+1})| &lt; tol, consider x_{i+1} as the root and exit the loop.\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n\n\n\ndef secant_method(func, x0, x1, tol=1e-6, max_iter=100):\n    iter_count = 0\n    x_prev = x0\n    x_curr = x1\n    \n    iteration_data = []\n    print(\"Iteration |  x_curr  |   x_next | f(x_curr) |   Ea (%)\")\n    print(\"---------------------------------------------------------\")\n    print(f\"{iter_count:9d} | {x_prev:.6f} | {x_curr:.6f} | {func(x_prev):.6f}\")\n    \n    while abs(x_curr - x_prev) &gt; tol and iter_count &lt; max_iter:\n        f_curr = func(x_curr)\n        f_prev = func(x_prev)\n        \n        x_next = x_curr - (f_curr * (x_curr - x_prev)) / (f_curr - f_prev)\n        Ea = abs((x_next - x_curr) / x_next) * 100\n        \n        iteration_data.append([iter_count + 1, x_curr, x_next, f_curr, Ea])\n        \n        print(f\"{iter_count + 1:9d} | {x_curr:.6f} | {x_next:.6f} | {f_curr:.6f} | {Ea:.3f}\")\n        \n        x_prev = x_curr\n        x_curr = x_next\n        \n        iter_count += 1\n    \n    return x_curr, np.array(iteration_data)\n\n\n\n\n\ndef function(x):\n    return np.exp(-x)-x\n\n\n\n\n\ninitial_guess1 = 2.5\ninitial_guess2 = 3.5\ntolerance = 1e-6\n\n\n\n\n\nroot, iteration_data = secant_method(function, initial_guess1, initial_guess2, tol=tolerance)\nprint(\"\")\nprint(\"Approximate root:\", root)\nprint(\"Function value at root:\", function(root))\n\nIteration |  x_curr  |   x_next | f(x_curr) |   Ea (%)\n---------------------------------------------------------\n        0 | 2.500000 | 3.500000 | -2.417915\n        1 | 3.500000 | 0.201356 | -3.469803 | 1638.214\n        2 | 0.201356 | 0.698861 | 0.616265 | 71.188\n        3 | 0.698861 | 0.576178 | -0.201710 | 21.293\n        4 | 0.576178 | 0.566933 | -0.014136 | 1.631\n        5 | 0.566933 | 0.567144 | 0.000330 | 0.037\n        6 | 0.567144 | 0.567143 | -0.000001 | 0.000\n\nApproximate root: 0.5671432904228986\nFunction value at root: -2.055255965416336e-11\n\n\n\nfor data in iteration_data[:4]:\n    iter_count, x_curr, x_next, f_curr, Ea = data\n    \n    plt.figure()\n    x_vals = np.linspace(min(x_curr, x_next) - 1, max(x_curr, x_next) + 1, 400)\n    y_vals = function(x_vals)\n    plt.plot(x_vals, y_vals, label='Function')\n    plt.scatter([x_curr, x_next], [f_curr, function(x_next)], color=['red', 'green'])\n    \n    plt.annotate('x_curr', (x_curr, f_curr), textcoords=\"offset points\", xytext=(0,10), ha='center', fontsize=15, color='red')\n    plt.annotate('x_next', (x_next, function(x_next)), textcoords=\"offset points\", xytext=(0,10), ha='center', fontsize=15, color='green')\n    \n    plt.axhline(y=0, color='black', linewidth=0.8)\n    plt.axvline(x=0, color='black', linewidth=0.8)\n    \n    plt.xlabel('x')\n    plt.ylabel('f(x)')\n    plt.legend()\n    plt.grid()\n    plt.title(f\"Iteration {iter_count}\")\n    plt.show()"
  }
]